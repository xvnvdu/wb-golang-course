package main

import (
	"fmt"
)

// Объявлять глобальную переменную в данном
// случае - не очень хорошая практика, особенно
// если эта же переменная будет использоваться
// в какой-то функции помимо someFunc.
// Если нужна некоторая переменная с глобальным
// доступом из любой точки приложения, пожалуй,
// лучше будет объявить константу
/*
	var justString string
*/

// Проблема старой реализации в том, что мы
// выделяем 2^10 (1024) байт памяти под строку,
// а затем используем лишь первые 100 байт из них.
// По завершении функции someFunc сборщик мусора
// не будет очищать те 1024 байт памяти, потому что
// ссылка на эту память хранится в переменной
// justString. И хотя данные не копируются, из-за
// того что ссылка на память активна и использует
// только ~десятую часть выделенного объема, может
// произойти утечка памяти, чего хотелось бы избежать
/*
	func someFunc() {
		v := createHugeString(1 << 10) // Выделяем 1024 байта
		justString = v[:100]           // Используем только первые 100
									   // Итого 924 байта не используются,
									   // мы используем память неэффективно
	}
*/

// Корректная реализация someFunc:
//
// Во-первых, если нам нужно взаимодействовать
// с переменной justString в других функциях,
// лучше будет объявлять и проводить манипуляции
// с ней внутри someFunc, затем возвращать значение,
// либо отдавать justString на вход функции
//
// Во-вторых, нам нужно освободить 1024 байта
// памяти, если мы хотя бы потенциально имеем
// шанс не использовать всю выделенную память
func someFunc() string {
	var justString string
	// Выделяем 1024 байта памяти
	// под переменную v
	v := createHugeString(1 << 10)
	// Записываем только нужные 100
	// байт в переменную justString.
	// v[:100] все еще содержит ссылку
	// на память, но через []byte() мы
	// создаем копию этих данных
	justString = string([]byte(v[:100]))
	// При завершении функции у нас есть
	// отдельная переменная на 100 байт,
	// а ранее выделенные 1024 байта больше
	// нигде не используются, поэтому
	// сборщик мусора освободит эту память
	return justString
}

func main() {
	str := someFunc() // Объявляем переменную
	fmt.Println(str)  // Как-нибудь используем ее
}

// Образец функции создания больших строк
func createHugeString(byteSize int) []byte {
	var hugeString []byte
	/*

		Здесь должна быть некоторая логика
		генерации строки указанного размера

	*/
	return hugeString
}
