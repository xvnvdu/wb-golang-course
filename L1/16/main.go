package main

import (
	"fmt"
)

// Обертка над рекурсивной функцией,
// возвращает отсортированный массив чисел
func quickSort(nums []int) []int {
	recursion(nums)
	return nums
}

// Рекурсивно "на месте" меняет местами
// элементы относительно опорного
func recursion(nums []int) {
	// Выходим если в массиве один
	// элемент - он отсортирован
	if len(nums) < 2 {
		return
	}

	// Опираемся на последний элемент
	p := len(nums) - 1
	var i, j int

	// Пока не дойдем до конца массива, будем
	// выталкивать бОльшие элементы ближе к
	// концу, меньшие же наоборот отсеивать
	// ближе к границе i
	for j < p {
		// Если элемент меньше опорного, кидаем
		// его ближе к границе, к началу массива,
		// меняя местами с бОльшим элементом
		if nums[j] <= nums[p] {
			nums[i], nums[j] = nums[j], nums[i]
			i++ // Сдвигаем границу дальше
		}
		j++ // Продвигаемся к концу массива
	}
	// Когда достигаем конца массива, меняем
	// местами последнее большее число и
	// опорный элемент, теперь слева от опорного
	// числа только меньше, а справа - только больше
	nums[i], nums[p] = nums[p], nums[i]

	// Уходим в рекурсию по двум получившимся массивам:
	// справа и слева от опорного элемента, не учитывая
	// сам опорный, тк он уже стоит на нужном месте,
	// текущая функция повторяется снова
	recursion(nums[:i])
	recursion(nums[i+1:])
}

func main() {
	nums := []int{5, 8, 9, 1, 3, 6, 4, 2, 10, 7}

	sortedNums := quickSort(nums)
	fmt.Println(sortedNums)
}
