package main

import (
	"fmt"
	"strconv"
)

// Целевой интерфейс, содержащий метод
// CountSheep(), который возвращает строку
type SheepCounter interface {
	CountSheep() string
}

// Удовлетворяющая целевому интерфейсу структура,
// имеет метод CountSheep(), который возвращает строку
type NewSheepCounter struct{}

// Условная легаси структура, которая имеет свои
// методы, отличающиеся от целевых. Не удовлетворяет
// интерфесу, но должна - при этом мы не можем
// изменять эту структуру напрямую (по разным причинам)
type LegacySheepCounter struct{}

// Адаптер, который удовлетворяет целевому интерфейсу,
// но использует под капотом несовместимую структуру.
// Выступает своего рода оберткой над легаси структурой.
// Содержит адаптируемый объект и делегирует ему вызов
type SheepCounterAdapter struct {
	lsc *LegacySheepCounter
}

// Удовлетворяющий интерфейсу метод структуры NewSheepCounter
func (nsc *NewSheepCounter) CountSheep() string {
	return "200 sheep"
}

// Метод структуры LegacySheepCounter не удовлетворяет интерфейсу:
// он имеет иное название и возвращает целые числа вместо строк
func (lsc *LegacySheepCounter) SheepAmountToFallAsleep() int {
	return 100
}

// Используем адаптер - обертку над несовместимым методом,
// чтобы удовлетворять целевому интерфейсу и вернуть строку
func (sca *SheepCounterAdapter) CountSheep() string {
	// Делегируем вызов несовместимой структуре
	// и получаем некоторые данные из ее метода
	sheepAmount := sca.lsc.SheepAmountToFallAsleep()
	// Можем провести необходимые манипуляции с
	// данными, чтобы подогнать их под нужный формат
	return strconv.Itoa(sheepAmount) + " sheep"
}

func main() {
	nsc := &NewSheepCounter{}
	newSheepCount := nsc.CountSheep()

	sca := &SheepCounterAdapter{}
	oldSheepCount := sca.CountSheep()

	fmt.Printf("Nowadays my cat from 4th task usually "+
		"counts to %s to fall asleep\n", newSheepCount)
	fmt.Printf("But when he was a kitten, it took him to "+
		"count only to %s to fall asleep\n", oldSheepCount)
}

/*
	Подобный паттерн может применяться в случаях, когда мы
	не можем изменить "капот" кода, с которым приходится
	работать. Это может быть легаси-код, сторонняя библиотека
	или просто критически важный код, трогать который нельзя.

	Адаптер позволяет унифицировать код, подогнать его под
	единый стиль и передать клиенту именно тот интерфейс,
	который он ожидает получить. Так мы не "стреляем в ногу"
	другим пользователям уже готового класса, которые могут
	его использовать в своем коде.

	Плюсы:
		Пожалуй, основные преимущества в том, что мы можем
		привести различные методы к общему шаблону и
		использовать разные компоненты приложения под единой
		унифицированной логикой, абстрагируясь от "капота" и
		реализуя единый "стиль", что значительно упростит
		разработку, в теории уменьшит количество кода и
		позволит реализовать централизованную структуру для
		управления отличающимися внутрянкой компонентами.

	Минусы:
		С другой стороны, эти же преимущества могут стать и
		недостатками: в некоторых случаях такой подход может
		только усложнить структуру проекта и превратить его
		в "капусту" из абстракций, где основная логика четко
		и последовательно определена, но из-за несовместимости
		компонентов и нужды управлять всеми модулями в едином
		стиле, "явный" код превращается в сплошные обертки, в
		чем потом будет гораздо труднее разобраться, теряется
		читаемость кода, его производительность, хоть и не
		сильно. В общем, это палка о двух концах.

	Пример:
		Реальный пример использования могу привести из своего
		собственного опыта: сейчас я работаю в команде над
		небольшим проектом и перед выполнением этого задания
		мне повезло реализовать подобный паттерн. В приложении
		используется несколько модулей, управление жизненными
		циклами которых происходило по-разному. Для унификации
		управления был реализован "контейнер", хранящий
		компоненты с единым интерфейсом, содержащий название
		компонента, метод запуска этого компонента и остановки.
		Так, к примеру, реализованные на данный момент кафка и
		редис, использовавшие разные механизмы инициализации,
		проверки соединения и завершения работы, теперь соответствуют
		единому интерфейсу и управляются сервисом централизованно
		из ядра приложения, а сам контейнер хранится в структуре ядра
*/
